#include "../include/IndirectJmpPass.h"

#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InlineAsm.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/GlobalVariable.h"
#include "llvm/IR/Module.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Transforms/Utils/ModuleUtils.h"
#include "llvm/Support/raw_ostream.h"
#include <random>
#include <set>
using namespace llvm;
std::map<BasicBlock *, unsigned> BBNumbering; // 基本块编号映射
std::vector<BasicBlock *> BBTargets;          
std::set<BasicBlock *> JumpedBBTargets;          
std::random_device RandomDevice;
std::mt19937 RandomEngine(RandomDevice());    // 随机数引擎

// 为函数的基本块编号
void NumberBasicBlock(Function &F)
{
  for (auto &BB : F)
  {
    if (auto *BI = dyn_cast<BranchInst>(BB.getTerminator()))
    {
      if (BI)
      {
        unsigned N = BI->getNumSuccessors();
        for (unsigned I = 0; I < N; I++)
        {
          BasicBlock *Succ = BI->getSuccessor(I);
          if (BBNumbering.count(Succ) == 0)
          {
            BBTargets.push_back(Succ);
            BBNumbering[Succ] = 0;
          }
        }
      }
    }
  }

  std::shuffle(BBTargets.begin(), BBTargets.end(), RandomEngine);

  unsigned N = 0;
  for (auto BB : BBTargets)
  {
    BBNumbering[BB] = N++;
  }
}

// 获取间接目标的全局变量
GlobalVariable *getIndirectTargets(Function &F, ConstantInt *EncKey)
{
  // 构造全局变量的名称
  std::string GVName(F.getName().str() + "_IndirectBrTargets");

  // 检查全局变量是否已经存在，如果存在则直接返回
  GlobalVariable *GV = F.getParent()->getNamedGlobal(GVName);
  if (GV)
    return GV;

  // 创建一个存放加密分支目标的向量
  std::vector<Constant *> Elements;
  for (auto BB : BBTargets)
  {
    // 获取基本块的地址，并将其转换为 i8* 类型
    Constant *CE = ConstantExpr::getBitCast(BlockAddress::get(BB), Type::getInt8PtrTy(F.getContext()));
    // 通过添加偏移量 EncKey 来加密地址
    CE = ConstantExpr::getGetElementPtr(Type::getInt8Ty(F.getContext()), CE, EncKey);
    // 将加密后的地址添加到向量中
    Elements.push_back(CE);
  }

  // 创建一个数组类型，元素类型为 i8*，长度为 Elements 的大小
  ArrayType *ATy = ArrayType::get(Type::getInt8PtrTy(F.getContext()), Elements.size());
  // 创建一个常量数组，用于存放加密后的分支目标
  Constant *CA = ConstantArray::get(ATy, ArrayRef<Constant *>(Elements));

  // 创建一个新的全局变量，用于存放加密后的分支目标数组
  GV = new GlobalVariable(*F.getParent(), ATy, false, GlobalValue::LinkageTypes::PrivateLinkage, CA, GVName);
  // 将该全局变量添加到编译器使用的全局变量列表中
  appendToCompilerUsed(*F.getParent(), {GV});

  return GV;
}

void createInlineAsm_MovAddr2X9(Function &F, IRBuilder<>  &Builder, Value *DestAddr)
{
  LLVMContext &Ctx = F.getContext();

  // 内嵌汇编代码
  std::string AsmString = "mov x9, $0";

  // 寄存器约束字符串
  std::string Constraints = "r,~{x9}";

  // 构造返回类型和参数类型列表
  Type *VoidTy = Type::getVoidTy(Ctx);
  Type *Int8PtrTy = Type::getInt8PtrTy(Ctx);
  FunctionType *InlineAsmTy = FunctionType::get(VoidTy, {Int8PtrTy}, false);

  // 构造内嵌汇编指令
  InlineAsm *IA = InlineAsm::get(InlineAsmTy, AsmString, Constraints, true, false, InlineAsm::AD_ATT);

  // 插入内嵌汇编指令调用
  Builder.CreateCall(IA, {DestAddr});
}

void createInlineAsm_MovAddr2X10(Function &F, IRBuilder<> &Builder, Value *DestAddr)
{
  LLVMContext &Ctx = F.getContext();

  // 内嵌汇编代码
  std::string AsmString = "mov x10, $0";

  // 寄存器约束字符串
  std::string Constraints = "r,~{x10}";

  // 构造返回类型和参数类型列表
  Type *VoidTy = Type::getVoidTy(Ctx);
  Type *Int64PtrTy = Type::getInt8PtrTy(Ctx);
  FunctionType *InlineAsmTy = FunctionType::get(VoidTy, {Int64PtrTy}, false);

  // 构造内嵌汇编指令
  InlineAsm *IA = InlineAsm::get(InlineAsmTy, AsmString, Constraints, true, false, InlineAsm::AD_ATT);

  // 插入内嵌汇编指令调用
  Builder.CreateCall(IA, {DestAddr});
}

void createInlineAsm_IndirectJumpByX9X10(Function &F, IRBuilder<> &Builder, Value *Cond,Instruction *BI)
{
  // 获取当前函数的上下文
  LLVMContext &Ctx = F.getContext();

  // 构建内联汇编字符串
  std::string AsmString;
  AsmString += "cbz $0, 1f\n"; // 如果条件为0，跳转到.Lfalse
  AsmString += "br x9\n";           // 否则跳转到x9存储的地址（True Addr）
  AsmString += "1:\n";
  AsmString += "br x10\n"; // 跳转到x10存储的地址（False Addr）

  // 构建内联汇编
  InlineAsm *IA = InlineAsm::get(FunctionType::get(Type::getVoidTy(Ctx), {Type::getInt1Ty(Ctx)}, false), AsmString, "r", true);

  // 创建调用指令
  Builder.CreateCall(IA, Cond);
  // IA->addDestination(BI->getSuccessor(0));
  // IA->addDestination(BI->getSuccessor(1));
}
void createInlineAsm_IndirectJumpByX9(Function &F, IRBuilder<> &Builder)
{
  // 获取当前函数的上下文
  LLVMContext &Ctx = F.getContext();

  // 构建内联汇编字符串
  std::string AsmString = "br x9";

  // 寄存器约束字符串
  std::string Constraints = "";

  // 构造返回类型和参数类型列表
  Type *VoidTy = Type::getVoidTy(Ctx);
  FunctionType *InlineAsmTy = FunctionType::get(VoidTy, {}, false);

  // 构造内嵌汇编指令
  InlineAsm *IA = InlineAsm::get(InlineAsmTy, AsmString, Constraints, true);

  // 插入内嵌汇编指令调用
  Builder.CreateCall(IA, {});
}

#include "llvm/Support/raw_ostream.h" // for llvm::errs()

PreservedAnalyses IndirectJmpPass::run(Function &F, FunctionAnalysisManager &AM)
{
    if (F.empty() || F.hasLinkOnceLinkage() || F.getSection() == ".text.startup")
    {
        llvm::errs() << "Skipping function: " << F.getName() << "\n"; // 输出跳过的函数名
        return PreservedAnalyses::all();
    }

    LLVMContext &Ctx = F.getContext();
    // 添加一个标记属性，表示禁用R0寄存器
    F.addFnAttr("disable-x9");
    F.addFnAttr("disable-x10");

    // 初始化成员字段
    BBNumbering.clear();
    BBTargets.clear();

    llvm::errs() << "Processing function: " << F.getName() << "\n"; // 输出正在处理的函数名

    // LLVM不能从IndirectBrInst拆分关键边
    SplitAllCriticalEdges(F, CriticalEdgeSplittingOptions(nullptr, nullptr));
    NumberBasicBlock(F);
    std::set<BasicBlock *> copyBBTargets(BBTargets.begin(), BBTargets.end());
    if (BBNumbering.empty())
    {
        llvm::errs() << "BBNumbering is empty, skipping function: " << F.getName() << "\n";
        return PreservedAnalyses::all();
    }

    uint32_t V = RandomEngine() & ~3;
    ConstantInt *EncKey = ConstantInt::get(Type::getInt32Ty(Ctx), V, false);

    ConstantInt *Zero = ConstantInt::get(Type::getInt32Ty(Ctx), 0);
    GlobalVariable *DestBBs = getIndirectTargets(F, EncKey);
    int block_count = 0;
    for (auto &BB : F)
    {
        llvm::errs() << "Processing BasicBlock: " << BB.getName() << "\n"; // 输出当前处理的基本块

        auto *BI = dyn_cast<BranchInst>(BB.getTerminator());
        if (BI && BI->isConditional())
        {
            llvm::errs() << "Found conditional branch in block: " << BB.getName() << "\n";

            // 在基本块的开头插入指令
            IRBuilder<> IRB(&BB, BB.getFirstInsertionPt());
            Value *Cond = BI->getCondition();
            Value *TIdx, *FIdx;

            TIdx = ConstantInt::get(Type::getInt32Ty(Ctx), BBNumbering[BI->getSuccessor(0)]);
            FIdx = ConstantInt::get(Type::getInt32Ty(Ctx), BBNumbering[BI->getSuccessor(1)]);

            Value *TGEP = IRB.CreateGEP(DestBBs->getValueType(), DestBBs, {Zero, TIdx});
            Value *FGEP = IRB.CreateGEP(DestBBs->getValueType(), DestBBs, {Zero, FIdx});
            LoadInst *TEncDestAddr = IRB.CreateLoad(Type::getInt8PtrTy(Ctx), TGEP, "TEncDestAddr");
            LoadInst *FEncDestAddr = IRB.CreateLoad(Type::getInt8PtrTy(Ctx), FGEP, "FEncDestAddr");

            // 计算解密密钥
            Value *DecKey = ConstantExpr::getSub(ConstantInt::get(Type::getInt32Ty(Ctx), 0), EncKey);
            Value *TDestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), TEncDestAddr, DecKey);
            Value *FDestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), FEncDestAddr, DecKey);
            Value *FakeDestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), FEncDestAddr, Zero);
            createInlineAsm_MovAddr2X9(F, IRB, TDestAddr);
            createInlineAsm_MovAddr2X10(F, IRB, FDestAddr);

            // 在基本块的结尾插入内嵌汇编指令
            IRBuilder<> EndIRB(BI);
            createInlineAsm_IndirectJumpByX9X10(F, EndIRB, Cond, BI);

            llvm::BasicBlock *CurrentBlock = BI->getParent(); // 获取当前块
            IndirectBrInst *IBI = IndirectBrInst::Create(FakeDestAddr, 2);
            while (1)
            {
                if (BBTargets[(block_count) % BBTargets.size()] != CurrentBlock && JumpedBBTargets.count(BBTargets[(block_count) % BBTargets.size()]) == 0)
                {
                    // 使用 ReplaceInstWithInst 将原来的分支指令替换为新创建的分支指令
                    JumpedBBTargets.insert(BBTargets[(block_count) % BBTargets.size()]);
                    IBI->addDestination(BBTargets[(block_count++) % BBTargets.size()]);
                    llvm::errs() << "Added destination for indirect branch: " << BBTargets[(block_count - 1) % BBTargets.size()]->getName() << "\n";
                    break;
                }
                else
                {
                    if (JumpedBBTargets == copyBBTargets)
                    {
                        llvm::errs() << "All blocks have been jumped to, breaking loop.\n";
                        break;
                    }
                    block_count++;
                }
            }

            while (1)
            {
                if (BBTargets[(block_count) % BBTargets.size()] != CurrentBlock && JumpedBBTargets.count(BBTargets[(block_count) % BBTargets.size()]) == 0)
                {
                    // 使用 ReplaceInstWithInst 将原来的分支指令替换为新创建的分支指令
                    JumpedBBTargets.insert(BBTargets[(block_count) % BBTargets.size()]);
                    IBI->addDestination(BBTargets[(block_count++) % BBTargets.size()]);
                    llvm::errs() << "Added another destination for indirect branch: " << BBTargets[(block_count - 1) % BBTargets.size()]->getName() << "\n";
                    break;
                }
                else
                {
                    if (JumpedBBTargets == copyBBTargets)
                    {
                        llvm::errs() << "All blocks have been jumped to, breaking loop.\n";
                        break;
                    }
                    block_count++;
                }
            }

            // 使用 ReplaceInstWithInst 将原来的分支指令替换为新创建的分支指令
            llvm::ReplaceInstWithInst(BI, IBI);
            llvm::errs() << "Replaced original branch with indirect branch in block: " << BB.getName() << "\n";
        }
        else if (BI)
        {
            llvm::errs() << "Found unconditional branch in block: " << BB.getName() << "\n";

            // 在基本块的开头插入指令
            IRBuilder<> IRB(&BB, BB.getFirstInsertionPt());
            Value *Idx;
            Idx = ConstantInt::get(Type::getInt32Ty(Ctx), BBNumbering[BI->getSuccessor(0)]);
            Value *GEP = IRB.CreateGEP(DestBBs->getValueType(), DestBBs, {Zero, Idx});
            LoadInst *EncDestAddr = IRB.CreateLoad(Type::getInt8PtrTy(Ctx), GEP, "EncDestAddr");
            // 计算解密密钥
            Value *DecKey = ConstantExpr::getSub(ConstantInt::get(Type::getInt32Ty(Ctx), 0), EncKey);
            Value *DestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), EncDestAddr, DecKey);
            createInlineAsm_MovAddr2X9(F, IRB, DestAddr);

            // 在基本块的结尾插入内嵌汇编指令
            IRBuilder<> EndIRB(BI);
            createInlineAsm_IndirectJumpByX9(F, EndIRB);

            llvm::BasicBlock *CurrentBlock = BI->getParent(); // 获取当前块
            while (1)
            {
                if (BBTargets[(block_count) % BBTargets.size()] != CurrentBlock && JumpedBBTargets.count(BBTargets[(block_count) % BBTargets.size()]) == 0)
                {
                    // 创建一个无条件的分支到自身
                    JumpedBBTargets.insert(BBTargets[(block_count) % BBTargets.size()]);
                    llvm::BranchInst *NewBranch = llvm::BranchInst::Create(BBTargets[(block_count++) % BBTargets.size()]);

                    // 使用 ReplaceInstWithInst 将原来的分支指令替换为新创建的分支指令
                    llvm::ReplaceInstWithInst(BI, NewBranch);
                    llvm::errs() << "Replaced original branch with new branch to: " << BBTargets[(block_count - 1) % BBTargets.size()]->getName() << "\n";
                    break;
                }
                else
                {
                    if (JumpedBBTargets == copyBBTargets)
                    {
                        llvm::errs() << "All blocks have been jumped to, breaking loop.\n";
                        break;
                    }
                    block_count++;
                }
            }
        }
    }
    return PreservedAnalyses::none();
}
